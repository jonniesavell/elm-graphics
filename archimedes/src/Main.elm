module Main where

import Array
import StartApp
import Task exposing (Task)
import Signal exposing (Signal, Address)
import Effects exposing (Effects, Never)
import Html exposing (Html)
import Html.Events exposing (..)
import Svg exposing (..)
import Svg.Attributes exposing (..)

--
-- StartApp boilerplate
--
app =
    StartApp.start {
      init = init,
      view = view,
      update = update,
      inputs = []
    }

main : Signal Html
main =
    app.html

port tasks : Signal (Task Never ())
port tasks =
    app.tasks

-------------------------------------------------------------------------------------
------ project notes, or 'how would i do something like this from scratch?' ---------
-------------------------------------------------------------------------------------
-- (1) everything above was generated by elm infrastructure
--     http://blog.jessitron.com/2015/11/getting-off-ground-in-elm-project-setup.html
--     (whenever i NEED the dope, i goto @VeryThorough)
--
-- (2) tooling notes courtesy of Richard Feldman
--     https://github.com/rtfeldman/elm-workshop
--
-- (3) i know of only one example using SVG
--     https://github.com/evancz/elm-svg
--
-- (4) the source of this project is Oswald Campesato's SVG work
--     https://github.com/ocampesato/reactjs-graphics (one of many)
--     as always, i am grateful to Oswald for making me suck less at front-end dev
-------------------------------------------------------------------------------------


-- type declarations
--
type alias Struct =
  {
    cx : Float,
    cy : Float,
    rx : Float,
    ry : Float,
    c  : String
  }

type alias Model =
  {
    name : String,
    structures : List Struct
  }

type Action = NoOp

-- functions
--
initialModel : Model
initialModel =
  {
    name = "archimedes",
    structures = List.reverse (generate 0 721 [])
  }

colors : Array.Array String
colors = Array.fromList ["#FF0000", "#0000FF"]

-- TODO #3: convert imperative logic to functional logic
generate : Int -> Int -> List Struct -> List Struct
generate angle maxAngle structures =
  if angle >= maxAngle
  then
    structures
  else
    let
      delta      = 1
      angle'     = angle + delta
      constant   = 0.25
      radius     = constant * (toFloat angle')
      offsetX    = radius * cos ((toFloat angle') * (pi/180.0))
      offsetY    = radius * sin ((toFloat angle') * (pi/180.0))
      basePointX = 250.0
      basePointY = 250.0
      currentX   = basePointX + offsetX
      currentY   = basePointY - offsetY
      majorAxis  = 40
      minorAxis  = 60
      color      = Maybe.withDefault "#FF00FF" (Array.get (angle' % 2) colors) 
    in
      generate
        angle'
        maxAngle
        ({ cx = currentX, cy = currentY, rx = majorAxis, ry = minorAxis, c = color } :: structures)


init : (Model, Effects Action)
init = ( initialModel, Effects.none)


update : Action -> Model -> (Model, Effects Action)
update action model =
    case action of
          NoOp -> (model, Effects.none)


view : Address Action -> Model -> Html
view address model =
    svg
      [ width "600", height "500" ]
      (List.map transformSingle model.structures)


-- TODO #1: create transformation logic: single structure to single Svg element
transformSingle : Struct -> Svg
transformSingle struct =
  ellipse
    [ cx (toString struct.cx), cy (toString struct.cy), rx (toString struct.rx), ry (toString struct.ry), fill (struct.c) ]
    []

-- TODO #2: create transformation logic: list of structures to list of Svg elements
-- function map does this (observe the call to List.map within function view)
